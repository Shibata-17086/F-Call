<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VOICEVOXæ¥ç¶šãƒ†ã‚¹ãƒˆ</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      max-width: 800px;
      margin: 50px auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .container {
      background: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h1 {
      color: #333;
      margin-bottom: 30px;
    }
    button {
      background: #007bff;
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 16px;
      border-radius: 5px;
      cursor: pointer;
      margin: 10px 5px;
    }
    button:hover {
      background: #0056b3;
    }
    #log {
      background: #000;
      color: #0f0;
      padding: 20px;
      border-radius: 5px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      max-height: 500px;
      overflow-y: auto;
      margin-top: 20px;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .success { color: #0f0; }
    .error { color: #f00; }
    .info { color: #0ff; }
    .warning { color: #ff0; }
    select {
      padding: 10px;
      font-size: 16px;
      border-radius: 5px;
      border: 1px solid #ddd;
      margin: 10px 5px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ”§ VOICEVOXæ¥ç¶šè¨ºæ–­ãƒ„ãƒ¼ãƒ«</h1>
    
    <div>
      <button onclick="testConnection()">1ï¸âƒ£ æ¥ç¶šãƒ†ã‚¹ãƒˆ</button>
      <button onclick="listSpeakers()">2ï¸âƒ£ ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ä¸€è¦§</button>
      <button onclick="testSpeech()">3ï¸âƒ£ éŸ³å£°ãƒ†ã‚¹ãƒˆ</button>
      <button onclick="clearLog()">ğŸ—‘ï¸ ãƒ­ã‚°ã‚¯ãƒªã‚¢</button>
    </div>
    
    <div style="margin: 20px 0;">
      <label>ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼:</label>
      <select id="speakerSelect">
        <option value="10">é›¨æ™´ã¯ã†ï¼ˆç”·æ€§é¢¨ï¼‰</option>
        <option value="2">å››å›½ã‚ãŸã‚“ï¼ˆãƒãƒ¼ãƒãƒ«ï¼‰</option>
        <option value="3">ãšã‚“ã ã‚‚ã‚“ï¼ˆãƒãƒ¼ãƒãƒ«ï¼‰</option>
        <option value="4">å››å›½ã‚ãŸã‚“ï¼ˆã‚»ã‚¯ã‚·ãƒ¼ï¼‰</option>
        <option value="5">ãšã‚“ã ã‚‚ã‚“ï¼ˆã‚»ã‚¯ã‚·ãƒ¼ï¼‰</option>
        <option value="17">ä¹å·ãã‚‰ï¼ˆã‚»ã‚¯ã‚·ãƒ¼ï¼‰</option>
        <option value="66" selected>ã‚‚ã¡å­ã•ã‚“ï¼ˆã‚»ã‚¯ã‚·ãƒ¼ï¼ã‚ã‚“å­ï¼‰</option>
      </select>
      
      <button onclick="testSelectedSpeaker()">é¸æŠã—ãŸã‚­ãƒ£ãƒ©ã§ãƒ†ã‚¹ãƒˆ</button>
    </div>
    
    <div id="log"></div>
  </div>

  <script>
    // F-Callã‚µãƒ¼ãƒãƒ¼çµŒç”±ã§VOICEVOXã«ã‚¢ã‚¯ã‚»ã‚¹ï¼ˆCORSå•é¡Œã‚’å›é¿ï¼‰
    const VOICEVOX_URL = '/api/voicevox';
    const logEl = document.getElementById('log');

    function log(message, type = 'info') {
      const timestamp = new Date().toLocaleTimeString();
      const className = type;
      logEl.innerHTML += `<span class="${className}">[${timestamp}] ${message}</span>\n`;
      logEl.scrollTop = logEl.scrollHeight;
      console.log(`[${type}] ${message}`);
    }

    function clearLog() {
      logEl.innerHTML = '';
    }

    async function testConnection() {
      log('=== æ¥ç¶šãƒ†ã‚¹ãƒˆé–‹å§‹ ===', 'info');
      
      try {
        log(`æ¥ç¶šå…ˆ: ${VOICEVOX_URL}`, 'info');
        
        const response = await fetch(`${VOICEVOX_URL}/version`);
        
        if (!response.ok) {
          throw new Error(`HTTPã‚¨ãƒ©ãƒ¼: ${response.status}`);
        }
        
        const version = await response.json();
        log(`âœ… æ¥ç¶šæˆåŠŸï¼VOICEVOXãƒãƒ¼ã‚¸ãƒ§ãƒ³: ${version}`, 'success');
        
        return true;
      } catch (error) {
        log(`âŒ æ¥ç¶šå¤±æ•—: ${error.message}`, 'error');
        log('åŸå› ã®å¯èƒ½æ€§:', 'warning');
        log('  1. VOICEVOXã‚¢ãƒ—ãƒªãŒèµ·å‹•ã—ã¦ã„ãªã„', 'warning');
        log('  2. ãƒãƒ¼ãƒˆ50021ãŒä½¿ç”¨ä¸­', 'warning');
        log('  3. ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«ã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã‚‹', 'warning');
        return false;
      }
    }

    async function listSpeakers() {
      log('=== ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ä¸€è¦§å–å¾— ===', 'info');
      
      try {
        const response = await fetch(`${VOICEVOX_URL}/speakers`);
        
        if (!response.ok) {
          throw new Error(`HTTPã‚¨ãƒ©ãƒ¼: ${response.status}`);
        }
        
        const speakers = await response.json();
        log(`âœ… ${speakers.length}å€‹ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒåˆ©ç”¨å¯èƒ½`, 'success');
        
        // ã‚»ã‚¯ã‚·ãƒ¼ç³»ã®ã¿è¡¨ç¤º
        log('\nğŸ’‹ ã‚»ã‚¯ã‚·ãƒ¼ç³»ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼:', 'info');
        speakers.forEach(speaker => {
          speaker.styles.forEach(style => {
            if (style.name.includes('ã‚»ã‚¯ã‚·ãƒ¼')) {
              log(`  - ${speaker.name}ï¼ˆ${style.name}ï¼‰: id=${style.id}`, 'success');
            }
          });
        });
        
      } catch (error) {
        log(`âŒ ã‚¨ãƒ©ãƒ¼: ${error.message}`, 'error');
      }
    }

    async function testSpeech() {
      await testSpeechWithSpeaker(66, 'ã‚‚ã¡å­ã•ã‚“ï¼ˆã‚»ã‚¯ã‚·ãƒ¼ï¼ã‚ã‚“å­ï¼‰');
    }

    async function testSelectedSpeaker() {
      const select = document.getElementById('speakerSelect');
      const speakerId = parseInt(select.value);
      const speakerName = select.options[select.selectedIndex].text;
      await testSpeechWithSpeaker(speakerId, speakerName);
    }

    async function testSpeechWithSpeaker(speakerId, speakerName) {
      log(`=== éŸ³å£°åˆæˆãƒ†ã‚¹ãƒˆ: ${speakerName} (id=${speakerId}) ===`, 'info');
      
      const testText = 'å—ä»˜ç•ªå·1ç•ªã®æ‚£è€…ã•ã¾ã€1ç•ªãƒ¦ãƒ‹ãƒƒãƒˆã¸ãŠè¶Šã—ãã ã•ã„';
      
      try {
        // ã‚¹ãƒ†ãƒƒãƒ—1: éŸ³å£°ã‚¯ã‚¨ãƒªç”Ÿæˆ
        log('ã‚¹ãƒ†ãƒƒãƒ—1: éŸ³å£°ã‚¯ã‚¨ãƒªã‚’ç”Ÿæˆä¸­...', 'info');
        const queryUrl = `${VOICEVOX_URL}/audio_query?text=${encodeURIComponent(testText)}&speaker=${speakerId}`;
        log(`ãƒªã‚¯ã‚¨ã‚¹ãƒˆ: ${queryUrl}`, 'info');
        
        const queryResponse = await fetch(queryUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          }
        });
        
        if (!queryResponse.ok) {
          const errorText = await queryResponse.text();
          log(`âŒ ã‚¯ã‚¨ãƒªç”Ÿæˆå¤±æ•—: ${queryResponse.status}`, 'error');
          log(`ã‚¨ãƒ©ãƒ¼å†…å®¹: ${errorText}`, 'error');
          throw new Error(`ã‚¯ã‚¨ãƒªç”Ÿæˆã‚¨ãƒ©ãƒ¼: ${queryResponse.status}`);
        }
        
        const audioQuery = await queryResponse.json();
        log('âœ… éŸ³å£°ã‚¯ã‚¨ãƒªç”ŸæˆæˆåŠŸ', 'success');
        
        // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š
        audioQuery.speedScale = 1.0;
        audioQuery.pitchScale = 0.0;
        audioQuery.intonationScale = 1.5;
        audioQuery.volumeScale = 1.2;
        audioQuery.prePhonemeLength = 0.1;
        audioQuery.postPhonemeLength = 0.1;
        audioQuery.outputSamplingRate = 48000;
        audioQuery.outputStereo = true;
        
        log('ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š:', 'info');
        log(`  - é€Ÿåº¦: ${audioQuery.speedScale}`, 'info');
        log(`  - ãƒ”ãƒƒãƒ: ${audioQuery.pitchScale}`, 'info');
        log(`  - æŠ‘æš: ${audioQuery.intonationScale}`, 'info');
        log(`  - ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ãƒ¬ãƒ¼ãƒˆ: ${audioQuery.outputSamplingRate}Hz`, 'info');
        
        // ã‚¹ãƒ†ãƒƒãƒ—2: éŸ³å£°åˆæˆ
        log('ã‚¹ãƒ†ãƒƒãƒ—2: éŸ³å£°åˆæˆä¸­...', 'info');
        const synthesisResponse = await fetch(`${VOICEVOX_URL}/synthesis?speaker=${speakerId}&enable_interrogative_upspeak=true`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'accept': 'audio/wav'
          },
          body: JSON.stringify(audioQuery)
        });
        
        if (!synthesisResponse.ok) {
          const errorText = await synthesisResponse.text();
          log(`âŒ éŸ³å£°åˆæˆå¤±æ•—: ${synthesisResponse.status}`, 'error');
          log(`ã‚¨ãƒ©ãƒ¼å†…å®¹: ${errorText}`, 'error');
          throw new Error(`éŸ³å£°åˆæˆã‚¨ãƒ©ãƒ¼: ${synthesisResponse.status}`);
        }
        
        const audioBlob = await synthesisResponse.blob();
        log(`âœ… éŸ³å£°åˆæˆæˆåŠŸ (ã‚µã‚¤ã‚º: ${(audioBlob.size / 1024).toFixed(2)} KB)`, 'success');
        
        // ã‚¹ãƒ†ãƒƒãƒ—3: å†ç”Ÿ
        log('ã‚¹ãƒ†ãƒƒãƒ—3: éŸ³å£°å†ç”Ÿä¸­...', 'info');
        const audioUrl = URL.createObjectURL(audioBlob);
        const audio = new Audio(audioUrl);
        
        audio.onended = () => {
          log('âœ… å†ç”Ÿå®Œäº†', 'success');
          URL.revokeObjectURL(audioUrl);
        };
        
        audio.onerror = (e) => {
          log(`âŒ å†ç”Ÿã‚¨ãƒ©ãƒ¼: ${e.message || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼'}`, 'error');
          URL.revokeObjectURL(audioUrl);
        };
        
        await audio.play();
        log('ğŸ”Š å†ç”Ÿé–‹å§‹ï¼', 'success');
        
      } catch (error) {
        log(`âŒ ãƒ†ã‚¹ãƒˆå¤±æ•—: ${error.message}`, 'error');
        log('ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹:', 'error');
        log(error.stack, 'error');
      }
    }

    // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«è‡ªå‹•æ¥ç¶šãƒ†ã‚¹ãƒˆ
    window.onload = async () => {
      log('ğŸš€ VOICEVOXè¨ºæ–­ãƒ„ãƒ¼ãƒ«èµ·å‹•', 'info');
      await testConnection();
    };
  </script>
</body>
</html>

